# 内存管理

### 说一下对 OC 内存管理的理解

> 2. ARC：是 OC 的内存管理机制，简单的说，就是代码中自动加入了 retain/release，原先需要手动添加来处理内存管理的引用计数的代码可以自动地由编译器完成。
> 2. 在 ARC 情况下，任何强指针（strong、retain）指向的对象就会被销毁；任何弱指针指向的对象不会被销毁；默认情况下对象都是强指针类型。
> 3. 自动释放池是 OC 的一种内存自动回收机制，可以将一些临时变量通过自动释放池来回收统一释放；内存池 autoreleasepool 是用于管理那些被声明为 autorelease 的对象，系统中有成千上万个内存池，系统内存不足时，系统会从栈中取最顶层的池子把引用计数为 0 的对象释放掉，收回内存给当前应用程序使用。自动释放池本身销毁时，池子里所有的对象都会做一次 release 操作。在使用 block 时，一定注意不能在 block 里面直接对对象进行操作，而是需要使用`__block`或者`__weak`进行修饰，避免循环引用，造成内存泄漏。

### 操作系统内存布局，各分为什么区？

> * 栈区：由系统区管理，地址从高到低分配，先进后出。会存一些局部变量，函数跳转时现场保护，这些都是系统处理，所以大量的局部变量、深递归、函数循环调用都可能耗尽栈内存而造成程序崩溃。
> * 堆区：需要开发人员管理内存，alloc 申请内存，release 释放内存。创建的对象也都放在这里，地址是从低到高分配。堆是所有程序共享的内存，当 N 个内存得不到释放，堆区会被挤爆崩溃。
> * 全局区/静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。
> * 常量区：常量字符串存放，还有 const 常量。
> * 代码区：存放 App 代码，App 程序会拷贝到这里。

### 堆和栈的区别

> 栈由编译器自动管理，无需手动控制；堆的释放需要开发人员控制，容易产生内存泄漏；
>
> 栈的存储顺序是由高地址向低地址，是一块连续的内存区域，能获得栈的空间较小，栈有两种分配方式：静态分配和动态分配；
>
> 堆的存储顺序是由低地址向高地址，是不连续的内存区域，堆获得的空间比较灵活也比较大，堆是动态分配和回收内存，没有静态分配的堆。

### 为什么要分堆和栈？不分堆和栈行吗？

> 1. 从软件设计角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。这种隔离、模块化的思想在软件设计方方面面都有体现；
> 2. 堆与栈的分离，使得堆中的内容可以被多个栈共享，这种共享提供了一种有效的数据交互方式，堆中的共享常量和缓存可以被所有栈访问，节省了空间；
> 3. 栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制栈的存储内容的能力。堆中的对象可以根据需要动态增长，因此堆和栈的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

### 为什么栈上面效率高

> 对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，是程序效率低。
>
> 对于栈来讲，遵循先进后出的队列，队列是一一对应的，不会先出一个内存块从栈中弹出。

### 僵尸对象、野指针、空指针分别指什么？有什么区别？

> * 僵尸对象：堆中已经被释放的对象（retainCount == 0）
> * 野指针：不是 NULL 指针，是指向一个非法的或者已经销毁的内存指针；
> * 空指针：指针赋值为 空
>   * 没有存储任何内存地址的指针成为空指针 NULL
>   * 空指针是被赋值为 0 的指针，在没有被具体初始化之前，其值为 0。

### 什么是虚拟内存、共享内存、物理内存

> * 虚拟内存：当我们向系统申请内存时，系统并不会给你返回物理内存的地址，而是给你一个虚拟内存地址。每个进程都拥有相同大小的虚拟地址空间，对于 32 位的进程，可以拥有 4GB 的虚拟内存，64 位进程，可达 18EB 。只有我们开始使用申请到的虚拟内存时，系统才会将虚拟地址映射到物理地址上，从而让程序使用真实的物理内存。
>
>   系统会对虚拟内存和物理内存进行分页，虚拟内存到物理内存的映射都是以页为最小粒度。
>
>   虚拟内存是在物理内存上建立的一个逻辑地址空间，它向上(应用)提供了一个连续的逻辑地址空间，向下隐藏了物理内存的细节。
>
>   虚拟内存使得逻辑地址可以没有实际的物理地址，也可以让多个逻辑地址对应到一个物理地址。
>
>   虚拟内存被划分为一个个大小相同的 page，提高管理和读写效率，page 又分为只读和读写。
>
> * 共享内存指在多处理的计算机系统中，可以被不同的 CPU 访问的大容量内存。
>
> * 物理内存：真实的硬件设备。

### 描述下`__block`和`__weak`修饰符的区别

> `__block`不管是 ARC 还是 MRC 模式，都可以使用，可以修饰对象，还可以修饰基本数据类型，`__block`对象可以在 block 中重新被赋值；
>
> `__weak`只能在 ARC 模式下使用，只能修饰对象，不可以在 block 中重新赋值。

## 实际问题

### 对于基本数据类型，一般是存储到栈中的，有没有可能存在堆上，什么情况下存到堆上？

> 栈和堆都是同属一块内存，只不过一个是高地址往低地址存储，一个从低地址往高地址存储，它们并没有严格的界限。所以基本数据类型也是可以存储到堆上的。
>
> 当该基本类型变量被 `__block`捕获时，该变量连同 block 都会被 copy 到堆上。

### 对象分配到堆还是栈

> OC 的对象在内存中是以堆的方式分配空间，并且堆内存是由开发者释放，就是 release；
>
> 非 OC 对象一般放在栈里。

### 堆为什么默认是 4G，是什么决定的？机器上插 16G 的内存条，虚拟内存只有 4G，是不是浪费？

> 每个进程都拥有相同大小的虚拟地址空间，对于 32 位的进程，可以拥有 4GB 的虚拟内存。
>
> 系统可以运行很多的进程，当进程开始真正使用内存时，会映射到物理内存上。

### 对象的 isa 指针指向哪里

> instance 对象的 isa 指向 class 对象；
>
> class 对象的 isa 指向 meta-class 对象；
>
> meta-class 对象的isa 指向基类的 meta-class 对象。

### iOS 开发中什么情况下会有野指针？

> 1. 指针未初始化；
> 2. 指针变量在定义时不会自动初始化成空指针，而是随机一个值，可能指向任意空间，这就使该指针成为野指针。因此指针初始化时要么指向一个合理的地址，要么初始化为 NULL；
> 3. 在释放空间后，指针指向的内容被销毁，空间被释放，当时指针的值并未改变，仍然指向这块内存，这就使得该指针成为野指针，因此在调用 free 或者 delete 之后，应该将该指针置为 NULL；
> 4. 指针操作超过所指向变量的生存期；
> 5. 当指针指向的变量的声明周期已经结束时，如果指针仍然指向这块空间，就会使得该指针成为野指针，养成良好的编码习惯，避免发生这样的情况。

### 栈会溢出吗？什么情况下会溢出

> 1. 在函数内部定义的超大数组会导致栈溢出
> 2. 递归次数过多

### 一个 OC 对象如何进行内存布局(考虑有父类情况)

> 最前面是 isa 指针，父类的成员变量存放在子类成员变量之前，所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中。
>
> 每个对象内部都有一个 isa 指针，指向他的类对象，类对象中放置着本对象的：对象方法列表、成员变量列表、属性列表。

### 一个 autorelease 对象在什么时候释放？

> 分两种情况：手动干预释放时机、系统自动去释放
>
> 手动干预释放：当前作用域大括号结束时释放
>
> 系统自动去释放：autorelease 对象在出了作用域之后，会在当前 runloop 结束时释放

### 引用计数为 0 的引用实例是立即回收吗？

> 对象的内存销毁分四个步骤：
>
> 1. 调用 release：引用计数变为 0
>    * 对象正在被销毁，生命周期即将结束
>    * 不能再有新的 `__weak`引用，否则将指向 nil
>    * 调用[self dealloc]
> 2. 子类调用 dealloc
>    * 继承关系中最底层的子类在调用 dealloc
>    * 如果是 MRC 代码，则会手动释放实例变量们
>    * 继承关系中每一层的父类在调用 dealloc
> 3. NSObject 调用 dealloc
>    * 只做一件事：调用 OC Runtime 中的 object_dispose() 方法
> 4. 调用 object_dispose()
>    * 为 C++ 的实例变量们调用 destructors
>    * 为 ARC 状态下的实例变量们调用 release
>    * 解除所有使用 runtime Associate 方法关联的对象
>    * 解除所有 __weak 引用
>    * 调用 free()

### 内存泄漏可能出现的几种原因

> 1. 第三方框架使用不当
> 2. block 循环引用
> 3. delegate 循环引用
> 4. NSTimer 循环引用
> 5. 非 OC 对象内存处理
> 6. 大次数的循环导致内存暴涨

### imageNamed和imageWithContentsOfFile的区别

> * imageNamed：这个方法生成的 UIImage 对象，会在应用的 bundle 中寻找图片，如果找到怎 Cache 到系统缓存中，作为内存的 Cache。开发者无法操作 Cahce，只能有系统自动处理，如果需要重复加载一张图片，系统能很快的从内存 Cache 中找到这张图，但是如果怕加载很大的图片，内存消耗过大，会强制释放内存，遇到内存警告
>
>   所以只适合于小的图片读取。
>
> * imageWithContentsOfFile：图片会被系统以数据的方式进行加载，在使用完成之后系统会直接释放，并不会缓存。一些使用次数比较少的操作可以使用这种方式，因为对内存的消耗比较小。