# 一、Objective-C 语言相关

### 1.属性关键字 strong、weak、assign、readwrite、readonly、copy、nonatomic、atomatic 各有什么作用？

> 1. strong：表示指向并拥有该对象。其修饰的对象引用计数会 + 1，该对象的引用计数不为 0，就不会被销毁，强行将其置为 nil，也可以销毁。
> 2. weak：表示指向但不拥有该对象，其修饰的对象引用计数不会增加，无需手动设置，该对象会自行在内存中被销毁。
> 3. assign：主要用于修改基本数据类型。
> 4. weak一般用来修饰对象，assign一般用来修饰基本数据类型，因为 assign 修饰的对象被释放后，指针地址依然存在，造成野指针，在堆上容易造成崩溃，而栈上的内存系统会自动处理。
> 5. readwrite： 可读可写属性，需要生成 getter、setter 方法
> 6. readonly：只读属性。只会生成 getter 方法
> 7. copy：与 strong 类型，不同之处是 strong 的复制是多个指针指向同一个地址，而 copy 的复制每次会在内存中复制一份对象，指针指向不同地址。copy 一般用在修饰对应可变类型的不可变对象上，如：NSString、NSArray、NSDictionary。
> 8. nonatomic：修饰的对象不保证 setter 和 getter 的完整性，所以当多个线程访问它时，可能会返回未初始化的对象，正因为如此，nonatomic 比 atomic 的速度快，但是线程是不安全的。
> 9. atomatic：修饰的对象会保证 setter 和 getter 的完整行，任何线程访问它都可以得到一个完整的初始化后的对象，因为要保证操作完成，所以速度比较慢。不是绝对的线程安全，要想线程绝对安全，需要用 @synchronized

### 2.copy 与 mutableCopy 方法

> 1. 对不可变对象进行 copy 操作是指针复制，mutableCopy 是内容复制
> 2. 对可变对象进行 copy 和 mutablecopy 都是内容复制

### 3.@property (nonatomic, copy) NSMutableArray *arr; 这个写法有什么问题？

> 添加、删除，修改数组元素时会崩溃。
>
> copy 返回的是一个不可变对象

### 4.#import 和 #include 有什么区别？@class 呢？#import<> 跟 #import""有什么区别？

> 1. #import 是 OC 导入头文件的关键字，#include 是 C/C++导入头文件的关键字；使用 #import 头文件只会导入一次，不会重复导入
> 2. @class 是告诉编译器某个类的声明，当执行时才会去查看类的实现文件，可以解决头文件的相互包含
> 3. #import<> 用来包含系统的头文件，#import"" 用来包含用户头文件

### 5.描述下 synthesize 与 dynamic 的作用

> 1. 如果 @synthesize 和 @dynamic 都没写，默认是 @synthesize var = _var;
> 2. @synthesize 的语义是如果没有手动实现 setter 方法和 getter 方法，那么编译器会自动加上这两个方法；
> 3. @dynamic 是告诉编译器，属性的 setter 和 getter 方法由用户自己实现，不自动生成。（编译的时候不会报错，但是当程序运行到 instance.var = someVar 时，由于缺少setter 方法，会导致崩溃；或者 调用到 getter 方法时会崩溃）

### 6.类变量的 @public、@protected、@private、@package 各有什么含义

> * @public 任何地方都可以访问
> * @protected 该类和子类中访问
> * @private 只能在本类中访问
> * @package 只能在本包内使用

### 7.分类、类扩展和继承在实现中有何区别？

> 2. 分类只能扩展方法，类扩展可以扩展属性、成员和方法
> 3. 继承可以增加、修改或者删除方法，可以增加属性

> 正常情况下，在 Category 中添加属性会报错，提示找不到 getter 和 setter方法，因为 category 不会自动生成这两个方法。可以引入运行时头文件，并配合关联对象的方法来实现，主要涉及两个函数是 objc_getAssociatedObject 和 objc_setAssociatedObject。

### 8.OC 的类可以多重继承吗？可以实现多个接口吗？重写一个类时用继承好还是分类好？

> 不可以多重继承；
>
> 可以实现多个接口，通过实现多个接口可以完成类似多重继承的效果；
>
> 用分类去重写类的方法，仅对本分类有效，不会影响到其他的类与原有类的关系。

### 9.常见的 OC 数据类型有哪些？和 C 的基本数据类型有什么区别？如 NSInteger 和 int

> OC 的数据类型有 NSString、NSNumber、NSArray、NSMutableArray、NSData 等，这些都是 class。创建后都是 对象。
>
> C 语言的基本数据类型 int ，只是一定字节的内存空间，用于存放数值；NSInteger 时OC 的基本数据类型，并不是 NSNumber 的子类，NSInteger 是基本数据类型 int 或者 long 的别名，会根据系统是 32 位还是 64 位来决定本身是 int 还是 long。

### 10.说一下深拷贝与浅拷贝的区别

> 深拷贝：即会复制对象的指针也会复制对象属性的地址；
>
> 浅拷贝：只复制对象的指针，不会复制对象的属性的地址。

### 11.下面的代码输出什么？

```objc
@implementation Son : Father
- (id)init {
   if (self = [super init]) {
       NSLog(@"%@", NSStringFromClass([self class])); // Son
       NSLog(@"%@", NSStringFromClass([super class])); // Son
   }
   return self;
}
@end
```

> 解析：
>
> * self 是类的隐藏参数，指向当前调用方法的这个类的实例
> * super 本质是一个编译器标志符，和 self 指向同一个消息接收者
> * super 会告诉编译器，调用这个 class 方法时，要去父类方法，而不是本类里
> * 上面的例子中，接收消息的对象都是当前 Son *obj 这个对象

### 12.描述一下对 block 的理解，它的作用有哪些？

> block 类似一个匿名的函数代码块，此代码块可以作为参数传递对象或方法，也可以作为方法的返回值；
>
> block 可以实现两个类之间的信息传递，并且 block 对局部变量是只读的，如果要修改，需要对变量加上 `__block`进行修饰
>
> block 是获取其他函数局部变量的匿名函数，功能是保存代码片段，预先准备好代码，在需要的时候执行。

### 13.使用 block 会产生内存泄漏吗？怎么解决？

> 当在 block 中之间调用局部对象或者当前对象 self 的属性或方法时，局部对象或者当前对象就会隐性的 retain 一次，导致相互引用；
>
> 可以加`__block`或者使用完之后立即释放 block（即 self.block = nil），防止内存泄漏。

### 14.一个 int 变量被 __block 修饰与否的区别

> * 没有修饰，被 block 捕获，是值拷贝
> * 修饰后，会生成一个结构体，复制 int 的引用地址，达到修改数据

### 15.block 修改 NSMutableArray 是否需要 __block 关键字

> 如果修改 NSMutableArray 的存储内容，不需要加
>
> 如果修改 NSMutableArray 本身，需要加

### 16.什么情况下编译器会自动将栈上的 block 拷贝到堆内存？

> 1. block 作为函数的返回值
> 2. 将 block 赋值给附有 __strong 修饰符 id 类型的类或者 block 类型的成员变量时
> 3. 方法中含有 useingBlock 的 cocoa 框架方法或者 GCD 的 API 中传递 block 时
> 4. 调用 block 的 copy 函数时

# 二、swift 语言相关

### 1.swift 是面向对象还是函数式编程语言？

> swift 既是面向对象的编程语言，又是函数式编程语言。
>
> 面向对象：支持类的封装、继承和多态；
>
> 函数式：支持 map、filter、flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。

### 2.swift 中 struct 和 class 有什么区别

> struct 是值引用，存放于栈区；无法继承；
>
> class 是类型引用，存放于堆区；可以继承。

> class 如下功能是 struct 没有的：
>
> * 可以继承
> * 类型转换可以再运行时检查和解释一个实例的类型
> * 可以用 deinit 来释放资源
> * 一个类可以被多次引用。

> struct 的优势：
>
> * 结构较小，适用于复制操作，相比一个 class 的实例被多次引用，struct 更加安全
> * 无需担心内存泄漏或者多线程冲突

### 3.什么时候用 struct

> 1. 模型较小时
> 2. 无需继承时
> 3. 无需序列化为 NSData 对象时（无需存储到 UserDefault 或 plist）
> 4. 无需 Objective-C使用时
> 5. 对变量不做变化时
> 6. 对变量的变化不需要传递时

###  3.什么是可选型(optional)

> 可选型是为了表达当一个变量值为空的情况。当一个变量值为空时，他就是一个 nil。在 swift 中无论变量是引用类型还是值类型，都可以是可选型变量。

> 在 OC 中没有明确提出可选型的概念，然而其引用类型却可以为 nil，以此来标示其变量值为空的情况。

### 4.什么是泛型(generics)

> 泛型主要是为增加代码的灵活性而生，它可以使对应的代码满足任意类型的变量或者方法。

### 5.说明并比较关键词：Open、Public、Internal、File-private 和 Provate

> 它们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如：一个 Private 的 class 中不能含有 Public 的 string 值。反之，低级别的变量却可以定义在高级别的变量中，比如：Public 的 class 中可以含有 Private 的 Int 值。
>
> * Open：具备最高访问权限。其修饰的类和方法可以在任意的 Module 中被访问和重写。
> * Public：权限仅次于 Open。与 Open 唯一的区别在于，它修饰的对象可以在任意 Module 中访问，但是不能重写。
> * Internal：默认权限。表示只能在当前定义的 Module 中访问和重写。可以被一个 Module 中的多个文件访问。
> * File-private：修饰的对象只能在当前文件中使用。
> * Private：最低级别的访问权限，修饰的对象只能在定义的作用域内使用。

### 6.如何理解 swift 中的 copy-on-write

> 当值类型在复制时，复制的对象和原对象实际上在内存中指向同一个对象。当且仅当修改复制后的对象时，才会在内存中重新创建一个新的对象。
>
> 因此内存使用更加高效。

### 7.比较 weak 和 Unowned

> weak: 弱引用，当一个被 weak 修饰的对象被释放后，弱引用也随即消失，继续访问该对象会得到 nil，不会崩溃
>
> Unowned： 弱引用，被 Unowned 修饰的对象被释放后，依然有一个无效的引用指向对象，继续访问该对象程序会崩溃。

### 8.什么是属性观察(Property Observer)

> 属性观察是指在当前类型内对特定的属性进行监听，并做出响应的行为，属性观察是 swift 的特性，具体有两种：willSet 和 didSet。
>
> 初始化方法对属性的设置，以及在 willSet 和 didSet 中对属性的再次设定，都不会触发调用属性观察。

### 9.闭包

#### 1、常用定义
> **闭包**
> 
> 一个捕获了全局上下文的常量或变量的函数。
> 
>**全局函数**
>
> 一种特殊的闭包，是一个名字但不会不会任何变量的闭包。
>
>**内嵌函数**
>
> 一个有名字并可以捕获其封闭函数域内值的闭包。
>
>**闭包表达式**
>
>  一个利用轻量级语法所写的可以捕获上下文中变量和常量值的匿名闭包。

#### 2、闭包的优化
> * 利用上下文推断参数和返回值类型
> * 单表达式闭包可以省略 return 关键字
> * 参数名称可以用 $0  $1 代替

#### 3、尾随闭包
> 如果函数最后一个参数是闭包，则闭包可以写在形参小括号的外面

#### 4.值捕获
> 全局变量：直接访问，不用捕获
> 局部变量：捕获到堆上

#### 5.非逃逸闭包
> 闭包调用发生在函数结束之前，闭包调用在函数作用域内。

#### 6.逃逸闭包
> 闭包调用可能在函数结束后，调用逃离了函数的作用域
> 在函数作用域内没有调用闭包，而是赋值给了一个变量
> 需要用 escaping 修饰

**非逃逸闭包、逃逸闭包都是将闭包作为一个实际参数传递给函数**


# 三、通知、代理

> 通知是一对多的关系，当一个类需要跟多个类进行信息传递的时候，一般都是用消息通知；通知是同步的，使用时必须先注册并绑定接收通知的方法，消息中心创建消息内容，然后发送通知；不在监听时，移除监听通知对象

> delegate 是类与类之间信息传递的一种方式，使用 delegate 时，必须先声明协议，确认协议并实现协议中声明的方法，添加要委托的对象。
>
> 支持一对多，可以把 delegate 改成数组保存多个对象，调用时，取出每一个对象进行信息传递。

### 7.多次添加同一个通知会是什么结果？多次移除呢？

> 多次添加同一个通知，会导致发送一次通知时，响应多次。
>
> 多次移除通知不会产生 crash。